Index: libmtp-1.1.2/src/libmtp.h.in
===================================================================
--- libmtp-1.1.2/src/libmtp.h.in	(revision 6)
+++ libmtp-1.1.2/src/libmtp.h.in	(working copy)
@@ -886,6 +886,14 @@
 			       void *,
 			       LIBMTP_progressfunc_t const,
 			       void const * const);
+int LIBMTP_Get_Partialobject_To_Buffer(LIBMTP_mtpdevice_t *,
+					uint32_t const ,
+					uint32_t ,
+					uint32_t ,
+					unsigned char **,
+					uint32_t *,				
+					LIBMTP_progressfunc_t const ,
+					void const * const );
 int LIBMTP_Send_File_From_File(LIBMTP_mtpdevice_t *,
 			       char const * const,
 			       LIBMTP_file_t * const,
Index: libmtp-1.1.2/src/ptp.h
===================================================================
--- libmtp-1.1.2/src/ptp.h	(revision 6)
+++ libmtp-1.1.2/src/ptp.h	(working copy)
@@ -2785,7 +2785,30 @@
 	}
 	return 0;
 }
+static inline int
+ptp_operation_isok(PTPParams* params,uint16_t *operations,int size)
+{
+	
+	int i=0;
+	int find_0x8xxx_op=0;
+	for (i=0;i<size;i++) {
+		//printf("op=%.4x\n",*(operations+i));
+		if(ptp_operation_issupported(params,*(operations+i))!=1){
+			return 0;
+		}
+	}
+	for (i=0;i<params->deviceinfo.OperationsSupported_len;i++) {
+		if (params->deviceinfo.OperationsSupported[i]&0x8000)
+		{
+			//printf("op=%.4x\n",params->deviceinfo.OperationsSupported[i]);
+			find_0x8xxx_op=1;
+			break;
+		}
+	}
+	return find_0x8xxx_op;
+}
 
+
 int ptp_event_issupported	(PTPParams* params, uint16_t event);
 int ptp_property_issupported	(PTPParams* params, uint16_t property);
 
Index: libmtp-1.1.2/src/libusb-glue.c
===================================================================
--- libmtp-1.1.2/src/libusb-glue.c	(revision 6)
+++ libmtp-1.1.2/src/libusb-glue.c	(working copy)
@@ -540,14 +540,12 @@
 	   * By thomas_-_s: Also append devices that are no MTP but PTP devices
 	   * if this is commented out.
 	   */
-	  /*
 	  else {
 	    // Check whether the device is no USB hub but a PTP.
 	    if ( dev->config != NULL &&dev->config->interface->altsetting->bInterfaceClass == USB_CLASS_PTP && dev->descriptor.bDeviceClass != USB_CLASS_HUB ) {
 	      *mtp_device_list = append_to_mtpdevice_list(*mtp_device_list, dev, bus->location);
 	    }
           }
-	  */
         }
       }
     }
Index: libmtp-1.1.2/src/libmtp.sym
===================================================================
--- libmtp-1.1.2/src/libmtp.sym	(revision 6)
+++ libmtp-1.1.2/src/libmtp.sym	(working copy)
@@ -51,6 +51,7 @@
 LIBMTP_Get_Filemetadata
 LIBMTP_Get_File_To_File
 LIBMTP_Get_File_To_File_Descriptor
+LIBMTP_Get_Partialobject_To_Buffer
 LIBMTP_Send_File_From_File
 LIBMTP_Send_File_From_File_Descriptor
 LIBMTP_new_filesampledata_t
Index: libmtp-1.1.2/src/libmtp.c
===================================================================
--- libmtp-1.1.2/src/libmtp.c	(revision 6)
+++ libmtp-1.1.2/src/libmtp.c	(working copy)
@@ -1773,6 +1773,17 @@
  * @param rawdevice the raw device to open a "real" device for.
  * @return an open device.
  */
+
+uint16_t operations[]={
+	0x1001,				/*get device info*/
+	0x1002,				/*Open session*/
+	0x1003,				/*Close session*/
+	0x1004,				/*Get storage IDs*/
+	0x1005,				/*Get storage info*/
+	0x1008,				/*Get object info*/
+	0x101b,				/*Get partial object*/
+};
+
 LIBMTP_mtpdevice_t *LIBMTP_Open_Raw_Device_Uncached(LIBMTP_raw_device_t *rawdevice)
 {
   LIBMTP_mtpdevice_t *mtp_device;
@@ -1860,6 +1871,32 @@
     return NULL;
   }
 
+  int code_it=0;
+
+  printf("Supported operations:\n");
+
+  printf("current_params->deviceinfo.OperationsSupported_len=%d\n",current_params->deviceinfo.OperationsSupported_len);
+  for (code_it=0;code_it<current_params->deviceinfo.OperationsSupported_len;code_it++) {
+    char txt[256];
+
+    (void) ptp_render_opcode(current_params, current_params->deviceinfo.OperationsSupported[code_it],
+			     sizeof(txt), txt);
+    printf("   %04x: %s\n", current_params->deviceinfo.OperationsSupported[code_it], txt);
+  }
+  if (!ptp_operation_isok(current_params,operations,sizeof(operations)/sizeof(uint16_t))) {
+    LIBMTP_ERROR("LIBMTP PANIC: Unable to read device information on device "
+	    "%d on bus %d, trying to continue",
+	    rawdevice->devnum, rawdevice->bus_location);
+
+    /* Prevent memory leaks for this device */
+    free(mtp_device->usbinfo);
+    free(mtp_device->params);
+    current_params = NULL;
+    free(mtp_device);
+    return NULL;
+  }
+
+
   /* Check: if this is a PTP device, is it really tagged as MTP? */
   if (current_params->deviceinfo.VendorExtensionID != 0x00000006) {
     LIBMTP_ERROR("LIBMTP WARNING: no MTP vendor extension on device "
@@ -1874,8 +1911,8 @@
 		 "Trying to continue anyway.");
   }
 
-  parse_extension_descriptor(mtp_device,
-                             current_params->deviceinfo.VendorExtensionDesc);
+  //parse_extension_descriptor(mtp_device,
+                             //current_params->deviceinfo.VendorExtensionDesc);
 
   /*
    * Android has a number of bugs, force-assign these bug flags
@@ -1930,6 +1967,7 @@
   }
 
   /* Determine if the object size supported is 32 or 64 bit wide */
+/*
   for (i=0;i<current_params->deviceinfo.ImageFormats_len;i++) {
     PTPObjectPropDesc opd;
 
@@ -1967,6 +2005,7 @@
       }
     }
   }
+*/
   if (bs == 0) {
     // Could not detect object bitsize, assume 32 bits
     bs = 32;
@@ -4066,7 +4105,9 @@
     uint32_t propcnt = 0;
     int ret;
 
+
     // First see which properties can be retrieved for this object format
+    /*
     ret = ptp_mtp_getobjectpropssupported(params, map_libmtp_type_to_ptp_type(file->filetype), &propcnt, &props);
     if (ret != PTP_RC_OK) {
       add_ptp_error_to_errorstack(device, ret, "obj2file: call to ptp_mtp_getobjectpropssupported() failed.");
@@ -4087,6 +4128,7 @@
       }
       free(props);
     }
+    */
   }
 
   return file;
@@ -5055,6 +5097,67 @@
 }
 
 /**
+ * This gets partialobject of a file off the device to a buffer
+ *
+ * @see LIBMTP_Get_File_To_File()
+ */
+int LIBMTP_Get_Partialobject_To_Buffer(LIBMTP_mtpdevice_t *device,
+					uint32_t const id,
+					uint32_t offset,
+					uint32_t maxbytes,
+					unsigned char **buf,
+					uint32_t *len,				
+					LIBMTP_progressfunc_t const callback,
+					void const * const data)
+{
+  uint16_t ret;
+  PTPParams *params = (PTPParams *) device->params;
+  PTP_USB *ptp_usb = (PTP_USB*) device->usbinfo;
+  PTPObject *ob;
+
+  ret = ptp_object_want (params, id, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+  if (ret != PTP_RC_OK) {
+    add_error_to_errorstack(device, LIBMTP_ERROR_GENERAL, "LIBMTP_Get_Partialobject_To_Buffer(): Could not get object info.");
+    return -1;
+  }
+  if (ob->oi.ObjectFormat == PTP_OFC_Association) {
+    add_error_to_errorstack(device, LIBMTP_ERROR_GENERAL, "LIBMTP_Get_Partialobject_To_Buffer(): Bad object format.");
+    return -1;
+  }
+
+  // Callbacks
+  ptp_usb->callback_active = 1;
+  ptp_usb->current_transfer_total = ob->oi.ObjectCompressedSize+
+    PTP_USB_BULK_HDR_LEN+sizeof(uint32_t); // Request length, one parameter
+  ptp_usb->current_transfer_complete = 0;
+  ptp_usb->current_transfer_callback = callback;
+  ptp_usb->current_transfer_callback_data = data;
+
+  ret = ptp_getpartialobject (params, id , 
+			offset,
+			maxbytes, 
+			buf ,
+			len);
+			
+  //ret = ptp_getobject_tofd(params, id, fd);
+
+  ptp_usb->callback_active = 0;
+  ptp_usb->current_transfer_callback = NULL;
+  ptp_usb->current_transfer_callback_data = NULL;
+
+  if (ret == PTP_ERROR_CANCEL) {
+    add_error_to_errorstack(device, LIBMTP_ERROR_CANCELLED, "LLIBMTP_Get_Partialobject_To_Buffer(): Cancelled transfer.");
+    return -1;
+  }
+  if (ret != PTP_RC_OK) {
+    add_ptp_error_to_errorstack(device, ret, "LIBMTP_Get_Partialobject_To_Buffer(): Could not get file from device.");
+    return -1;
+  }
+
+  return 0;
+}
+
+/**
  * This gets a file off the device and calls put_func
  * with chunks of data
  *
Index: libmtp-1.1.2/src/libmtp.h
===================================================================
--- libmtp-1.1.2/src/libmtp.h	(revision 6)
+++ libmtp-1.1.2/src/libmtp.h	(working copy)
@@ -886,6 +886,14 @@
 			       void *,
 			       LIBMTP_progressfunc_t const,
 			       void const * const);
+int LIBMTP_Get_Partialobject_To_Buffer(LIBMTP_mtpdevice_t *,
+					uint32_t const ,
+					uint32_t ,
+					uint32_t ,
+					unsigned char **,
+					uint32_t *,				
+					LIBMTP_progressfunc_t const ,
+					void const * const );
 int LIBMTP_Send_File_From_File(LIBMTP_mtpdevice_t *,
 			       char const * const,
 			       LIBMTP_file_t * const,
Index: libmtp-1.1.2/examples/filetree.c
===================================================================
--- libmtp-1.1.2/examples/filetree.c	(revision 6)
+++ libmtp-1.1.2/examples/filetree.c	(working copy)
@@ -57,9 +57,11 @@
       printf(" ");
     }
     printf("%u %s\n", file->item_id, file->filename);
+/*
     if (file->filetype == LIBMTP_FILETYPE_FOLDER) {
       recursive_file_tree(device, storage, file->item_id, depth+2);
     }
+*/
   }
 }
 
Index: libmtp-1.1.2/examples/getfile.c
===================================================================
--- libmtp-1.1.2/examples/getfile.c	(revision 6)
+++ libmtp-1.1.2/examples/getfile.c	(working copy)
@@ -23,6 +23,16 @@
 #include <stdlib.h>
 #include <limits.h>
 
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <errno.h>
+
 #include "common.h"
 #include "pathutils.h"
 #include "connect.h"
@@ -40,15 +50,49 @@
 getfile_function(char * from_path,char * to_path)
 {
   int id = parse_path (from_path,files,folders);
+  int filesize=0;
+  int toread=0;
+  int offset=0;
+  int maxbytes=65536;
+  int len=0;
+  int fd=-1;
+  unsigned char *buf = NULL;
+  LIBMTP_file_t *file_it=files;
+	
+  
   if (id > 0) {
     printf("Getting %s to %s\n",from_path,to_path);
-    if (LIBMTP_Get_File_To_File(device, id, to_path, progress, NULL) != 0 ) {
+#if 0 
+    if (LIBMTP_Get_File_To_File(device, id, to_path, progress, NULL) != 0 ) 
+#else
+	    if ( (fd = open(to_path, O_RDWR|O_CREAT|O_TRUNC,S_IRWXU|S_IRGRP)) != -1) {
+		    while(file_it!=NULL){
+			    if(file_it->item_id==id){
+				    filesize=file_it->filesize;
+				    break;
+			    }
+			    file_it=file_it->next;
+		    }
+                    printf("filesize=%d\n",filesize);
+		    while(toread<filesize){
+			    offset=toread;
+			    LIBMTP_Get_Partialobject_To_Buffer(device, id , offset ,maxbytes ,&buf , &len , NULL ,NULL);
+			    printf("getlen=%d\n",len);
+			    write(fd,buf,len);
+			    free(buf);
+                            buf=NULL;
+			    toread=toread+len;
+		    }
+		    close(fd);
+		}
+               printf("fd=%d\n",fd);
+   }else{
+#endif
       printf("\nError getting file from MTP device.\n");
       LIBMTP_Dump_Errorstack(device);
       LIBMTP_Clear_Errorstack(device);
       return 1;
     }
-  }
   return 0;
 }
 
